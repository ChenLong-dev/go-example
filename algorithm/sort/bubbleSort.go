package sort

import "fmt"

/*
冒泡排序原理：
过重复遍历待排序的数列，依次比较相邻的两个元素，如果它们的顺序错误就交换它们。这个过程反复进行直到没有需要交换的元素为止。

具体步骤如下：
1、从数列的起始位置开始，比较相邻的两个元素。
2、如果前一个元素大于后一个元素，则交换它们的位置。
3、对每一对相邻元素进行比较和可能的交换，直到最后一个元素。这一轮比较结束后，最大的元素会被“冒泡”到数列的末尾。
4、重复步骤1到步骤3，对剩余的未排序元素继续进行冒泡排序，直到所有元素都排序完成。

缺点：不适合大规模数据的排序，时间复杂度为O(n^2)。
优点：实现简单，容易理解。

时间复杂度：O(n^2)
空间复杂度：O(1)
稳定性：稳定

*/

// BubbleSort 冒泡排序（升序）
func BubbleSort(nums []int) []int {
	n := len(nums)
	if n == 0 {
		return nums
	}
	// 循环数组长度的次数
	for i := 0; i < n; i++ {
		/*
		从第0个元素开始，依次和后面的元素进行比较
		j<n-i-1 表示[n-i-1]个元素已经冒泡到了正确的位置，
		不需要再比较，可以减少比较次数
		*/
		for j := 0; j < n-i-1; j++ {
			if nums[j] > nums[j+1] {
				nums[j], nums[j+1] = nums[j+1], nums[j]
			}
		}
		fmt.Printf("第[%d]轮冒泡排序后的数组为：%v\n", i, nums)
	}
	return nums
}
