package sort

import "fmt"

/*
冒泡排序原理：
过重复遍历待排序的数列，依次比较相邻的两个元素，如果它们的顺序错误就交换它们。这个过程反复进行直到没有需要交换的元素为止。

具体步骤如下：
1、从数列的起始位置开始，比较相邻的两个元素。
2、如果前一个元素大于后一个元素，则交换它们的位置。
3、对每一对相邻元素进行比较和可能的交换，直到最后一个元素。这一轮比较结束后，最大的元素会被“冒泡”到数列的末尾。
4、重复步骤1到步骤3，对剩余的未排序元素继续进行冒泡排序，直到所有元素都排序完成。

缺点：不适合大规模数据的排序，时间复杂度为O(n^2)。
优点：实现简单，容易理解。

时间复杂度：O(n^2)
空间复杂度：O(1)
稳定性：稳定

*/

// BubbleSort 冒泡排序（升序）:https://www.bilibili.com/video/BV181421876R?spm_id_from=333.788.videopod.sections&vd_source=7459db3060f4a09b27ad55e8805e9f7c
func BubbleSort(nums []int) {
	n := len(nums)
	// 循环数组长度的次数
	for i := 0; i < n; i++ {
		flag := false // 标记是否进行过交换
		/*
			从第0个元素开始，依次和后面的元素进行比较
			j<n-i-1 表示[n-i-1]个元素已经冒泡到了正确的位置，
			不需要再比较，可以减少比较次数
		*/
		for j := 0; j < n-i-1; j++ { //
			if nums[j] > nums[j+1] { // 前一个元素大于后一个元素，则交换它们的位置
				nums[j], nums[j+1] = nums[j+1], nums[j] // 交换
				flag = true // 标记进行过交换
			}
		}
		fmt.Printf("第[%d]轮冒泡排序, flag=%v, temp:%d, 排序后的数组为：%v\n", i, flag, nums[n-i-1], nums)
		if flag == false { // 如果没有进行过交换，说明已经排序完成，可以退出循环
			break
		} else { // 否则，继续下一轮冒泡排序
			flag = false
		}

	}
}
